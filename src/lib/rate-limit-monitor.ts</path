import { RateLimiter } from './security';
import { NextRequest, NextResponse } from 'next/server';

// Rate limit monitoring arayÃ¼zÃ¼
export interface RateLimitViolation {
  id: string;
  timestamp: Date;
  identifier: string;
  ipAddress: string;
  endpoint: string;
  method: string;
  userAgent: string;
  attempts: number;
  maxAllowed: number;
  windowMs: number;
  isAuthenticated: boolean;
  userId?: string;
  violationType: 'limit_exceeded' | 'blacklisted_ip' | 'too_many_violations';
}

export interface RateLimitStats {
  totalRequests: number;
  blockedRequests: number;
  violationRate: number;
  topViolators: Array<{
    identifier: string;
    violations: number;
    lastViolation: Date;
  }>;
  endpointStats: Array<{
    endpoint: string;
    requests: number;
    violations: number;
    violationRate: number;
  }>;
  activeLimits: number;
  whitelistedIPs: number;
  blacklistedIPs: number;
}

// Rate limit monitoring servisi
export class RateLimitMonitor {
  private static violations: RateLimitViolation[] = [];
  private static maxViolations = 10000; // Son 10000 violation'Ä± sakla
  private static alertThresholds = {
    violationRate: 0.1, // %10 violation rate'de alert
    ipsPerHour: 100, // Saatte 100'den fazla IP'den violation
    endpointThreshold: 50 // Endpoint baÅŸÄ±na 50 violation'da alert
  };

  // Violation kaydet
  static recordViolation(violation: Omit<RateLimitViolation, 'id' | 'timestamp'>): void {
    const fullViolation: RateLimitViolation = {
      ...violation,
      id: crypto.randomUUID(),
      timestamp: new Date()
    };

    this.violations.push(fullViolation);

    // Maksimum violation sayÄ±sÄ±nÄ± aÅŸmayacak ÅŸekilde eski kayÄ±tlarÄ± sil
    if (this.violations.length > this.maxViolations) {
      this.violations = this.violations.slice(-this.maxViolations);
    }

    // Violation'larÄ± logla
    console.warn('ðŸš« Rate Limit Violation:', {
      endpoint: fullViolation.endpoint,
      ip: fullViolation.ipAddress,
      attempts: fullViolation.attempts,
      maxAllowed: fullViolation.maxAllowed,
      type: fullViolation.violationType
    });

    // Alert kontrolÃ¼
    this.checkAlerts(fullViolation);
  }

  // Ä°statistikleri getir
  static getStats(timeRange: '1h' | '24h' | '7d' | '30d' = '24h'): RateLimitStats {
    const now = new Date();
    let cutoffTime: Date;

    switch (timeRange) {
      case '1h':
        cutoffTime = new Date(now.getTime() - 60 * 60 * 1000);
        break;
      case '24h':
        cutoffTime = new Date(now.getTime() - 24 * 60 * 60 * 1000);
        break;
      case '7d':
        cutoffTime = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);
        break;
      case '30d':
        cutoffTime = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000);
        break;
    }

    const recentViolations = this.violations.filter(v => v.timestamp >= cutoffTime);
    const totalRequests = this.getTotalRequests(cutoffTime);
    const blockedRequests = recentViolations.length;

    // Top violators
    const violatorMap = new Map<string, { count: number; lastViolation: Date }>();
    recentViolations.forEach(v => {
      const existing = violatorMap.get(v.identifier);
      if (existing) {
        existing.count++;
        if (v.timestamp > existing.lastViolation) {
          existing.lastViolation = v.timestamp;
        }
      } else {
        violatorMap.set(v.identifier, { count: 1, lastViolation: v.timestamp });
      }
    });

    const topViolators = Array.from(violatorMap.entries())
      .map(([identifier, data]) => ({
        identifier,
        violations: data.count,
        lastViolation: data.lastViolation
      }))
      .sort((a, b) => b.violations - a.violations)
      .slice(0, 10);

    // Endpoint statistics
    const endpointMap = new Map<string, { requests: number; violations: number }>();
    recentViolations.forEach(v => {
      const existing = endpointMap.get(v.endpoint);
      if (existing) {
        existing.violations++;
      } else {
        endpointMap.set(v.endpoint, { requests: 0, violations: 1 });
      }
    });

    // TÃ¼m endpoint request'lerini say (approximate)
    this.addRequestCounts(endpointMap, cutoffTime);

    const endpointStats = Array.from(endpointMap.entries()).map(([endpoint, data]) => ({
      endpoint,
      requests: data.requests,
      violations: data.violations,
      violationRate: data.requests > 0 ? data.violations / data.requests : 0
    }));

    return {
      totalRequests,
      blockedRequests,
      violationRate: totalRequests > 0 ? blockedRequests / totalRequests : 0,
      topViolators,
      endpointStats: endpointStats.sort((a, b) => b.violations - a.violations),
      activeLimits: RateLimiter.getStats().activeLimits,
      whitelistedIPs: RateLimiter.getStats().whitelistedIPs,
      blacklistedIPs: RateLimiter.getStats().blacklistedIPs
    };
  }

  // Son violation'larÄ± getir
  static getRecentViolations(limit: number = 50): RateLimitViolation[] {
    return this.violations
      .slice(-limit)
      .reverse();
  }

  // IP bazÄ±nda istatistikler
  static getIPStats(ipAddress: string, timeRange: '1h' | '24h' | '7d' = '24h'): {
    violations: RateLimitViolation[];
    totalRequests: number;
    violationRate: number;
  } {
    const now = new Date();
    let cutoffTime: Date;

    switch (timeRange) {
      case '1h':
        cutoffTime = new Date(now.getTime() - 60 * 60 * 1000);
        break;
      case '24h':
        cutoffTime = new Date(now.getTime() - 24 * 60 * 60 * 1000);
        break;
      case '7d':
        cutoffTime = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);
        break;
    }

    const ipViolations = this.violations.filter(
      v => v.ipAddress === ipAddress && v.timestamp >= cutoffTime
    );

    return {
      violations: ipViolations,
      totalRequests: this.getIPRequestCount(ipAddress, cutoffTime),
      violationRate: this.getIPRequestCount(ipAddress, cutoffTime) > 0 
        ? ipViolations.length / this.getIPRequestCount(ipAddress, cutoffTime) 
        : 0
    };
  }

  // Alert kontrolÃ¼
  private static checkAlerts(violation: RateLimitViolation): void {
    const recentStats = this.getStats('1h');
    
    // YÃ¼ksek violation rate alert
    if (recentStats.violationRate > this.alertThresholds.violationRate) {
      console.warn('ðŸš¨ HIGH RATE LIMIT VIOLATION RATE!', {
        rate: recentStats.violationRate,
        threshold: this.alertThresholds.violationRate,
        violations: recentStats.blockedRequests
      });
    }

    // Ã‡ok fazla IP'den violation
    const uniqueIPs = new Set(recentStats.topViolators.map(v => v.identifier.split('-')[0]));
    if (uniqueIPs.size > this.alertThresholds.ipsPerHour) {
      console.warn('ðŸš¨ HIGH NUMBER OF VIOLATING IPs!', {
        uniqueIPs: uniqueIPs.size,
        threshold: this.alertThresholds.ipsPerHour
      });
    }

    // Endpoint-specific threshold
    const endpointViolation = recentStats.endpointStats.find(
      e => e.endpoint === violation.endpoint
    );
    if (endpointViolation && endpointViolation.violations > this.alertThresholds.endpointThreshold) {
      console.warn('ðŸš¨ HIGH VIOLATIONS ON ENDPOINT!', {
        endpoint: violation.endpoint,
        violations: endpointViolation.violations,
        threshold: this.alertThresholds.endpointThreshold
      });
    }
  }

  // YardÄ±mcÄ± methodlar
  private static getTotalRequests(cutoffTime: Date): number {
    // Bu basit bir approximation - gerÃ§ek uygulamada bir log sisteminden gelecek
    return RateLimiter.getStats().totalRequests;
  }

  private static addRequestCounts(endpointMap: Map<string, { requests: number; violations: number }>, cutoffTime: Date): void {
    // Bu method gerÃ§ek request log'larÄ±ndan beslenecek
    // Åžimdilik violation sayÄ±sÄ±ndan tÃ¼retilmiÅŸ bir approximation kullanÄ±yoruz
    endpointMap.forEach((data, endpoint) => {
      data.requests = Math.max(data.violations * 10, 1); // Minimum 1 request
    });
  }

  private static getIPRequestCount(ipAddress: string, cutoffTime: Date): number {
    // IP bazÄ±nda request count - gerÃ§ek log sisteminden gelecek
    const violations = this.violations.filter(
      v => v.ipAddress === ipAddress && v.timestamp >= cutoffTime
    );
    return violations.length * 10; // Approximation
  }

  // Monitoring reset
  static reset(): void {
    this.violations = [];
    console.log('ðŸ”„ Rate limit monitoring data reset');
  }

  // Export data
  static exportData(): string {
    return JSON.stringify({
      violations: this.violations,
      stats: this.getStats(),
      exportTime: new Date().toISOString()
    }, null, 2);
  }
}

// Next.js API Route handlers for monitoring
export async function GET(request: NextRequest) {
  const { searchParams } = new URL(request.url);
  const action = searchParams.get('action');
  const timeRange = (searchParams.get('timeRange') as '1h' | '24h' | '7d' | '30d') || '24h';
  const ip = searchParams.get('ip');

  try {
    switch (action) {
      case 'stats':
        const stats = RateLimitMonitor.getStats(timeRange);
        return NextResponse.json({
          success: true,
          data: stats
        });

      case 'violations':
        const limit = parseInt(searchParams.get('limit') || '50');
        const violations = RateLimitMonitor.getRecentViolations(limit);
        return NextResponse.json({
          success: true,
          data: violations
        });

      case 'ip-stats':
        if (!ip) {
          return NextResponse.json(
            { success: false, error: 'IP address required' },
            { status: 400 }
          );
        }
        const ipStats = RateLimitMonitor.getIPStats(ip, timeRange);
        return NextResponse.json({
          success: true,
          data: ipStats
        });

      case 'export':
        const exportData = RateLimitMonitor.exportData();
        return new NextResponse(exportData, {
          headers: {
            'Content-Type': 'application/json',
            'Content-Disposition': `attachment; filename="rate-limit-data-${new Date().toISOString()}.json"`
          }
        });

      case 'reset':
        RateLimitMonitor.reset();
        return NextResponse.json({
          success: true,
          message: 'Monitoring data reset successfully'
        });

      default:
        return NextResponse.json(
          { 
            success: false, 
            error: 'Invalid action',
            availableActions: ['stats', 'violations', 'ip-stats', 'export', 'reset']
          },
          { status: 400 }
        );
    }
  } catch (error: any) {
    console.error('Rate limit monitoring error:', error);
    return NextResponse.json(
      { success: false, error: 'Failed to get monitoring data' },
      { status: 500 }
    );
  }
}